{"version":3,"file":"static/js/431.55b4a137.chunk.js","mappings":"mBAaO,MAAMA,EA6BDC,WAAAA,CAAYC,GACnB,KA5BMC,2BAAqB,OACrBC,qBAAe,OAEfC,4BAAsB,OACtBC,sBAAgB,OAEhBC,oBAAc,OACdC,cAAQ,OAERC,uBAAiB,OACjBC,iBAAW,OAEXC,mBAAa,OACbC,aAAO,OAEPC,iBAAW,OACXC,WAAK,EAEZ,KACOC,uBAAiB,OACjBC,iBAAW,EAElB,KACOC,sBAAgB,OAChBC,gBAAU,OACVC,WAAK,EAIRC,KAAKjB,sBAAwBD,EAAWC,sBACxCiB,KAAKf,uBAAyBH,EAAWG,uBACzCe,KAAKb,eAAiBL,EAAWK,eACjCa,KAAKX,kBAAoBP,EAAWO,kBACpCW,KAAKT,cAAgBT,EAAWS,cAChCS,KAAKP,YAAcX,EAAWW,YAC9BO,KAAKL,kBAAoBb,EAAWa,kBACpCK,KAAKH,iBAAmBf,EAAWe,iBAEnCG,KAAKhB,gBAAkB,IAAIiB,aAAaD,KAAKjB,uBAC7CiB,KAAKd,iBAAmB,IAAIe,aAAaD,KAAKf,wBAC9Ce,KAAKZ,SAAW,IAAIa,aAAaD,KAAKb,gBACtCa,KAAKV,YAAc,IAAIW,aAAaD,KAAKX,mBACzCW,KAAKR,QAAU,IAAIS,aAAaD,KAAKT,eACrCS,KAAKN,MAAQ,IAAIO,aAAaD,KAAKP,aACnCO,KAAKJ,YAAc,IAAIM,WAAWF,KAAKL,mBACvCK,KAAKF,WAAa,IAAII,WAAWF,KAAKH,kBAEtCG,KAAKD,MAAQjB,EAAWiB,KAC5B,CAEA,aAAcI,CAAOC,GAEjB,MAAMC,EACN,CACItB,sBAAuB,IAAIuB,kBAAqC,EAAnBF,EAAuB,GACpEnB,uBAAwB,IAAIqB,kBAAqC,EAAnBF,EAAuB,GACrEjB,eAAgB,IAAImB,kBAAqC,EAAnBF,EAAuB,GAC7Df,kBAAmB,IAAIiB,kBAAqC,EAAnBF,GACzCb,cAAe,IAAIe,kBAAqC,EAAnBF,GACrCX,YAAa,IAAIa,kBAAqC,EAAnBF,EAAuB,GAC1DT,kBAAmB,IAAIW,kBAAqC,EAAnBF,GACzCP,iBAAkB,IAAIS,kBAAqC,EAAnBF,GACxCL,MAAO,GAELQ,EAAa,IAAI3B,EAAWyB,GAUlC,OATAE,EAAWvB,gBAAgBwB,KAAK,GAChCD,EAAWrB,iBAAiBsB,KAAK,GACjCD,EAAWnB,SAASoB,KAAK,GACzBD,EAAWjB,YAAYkB,KAAK,GAC5BD,EAAWf,QAAQgB,KAAK,GACxBD,EAAWb,MAAMc,KAAK,GACtBD,EAAWX,YAAYY,KAAK,GAC5BD,EAAWT,WAAWU,KAAK,GAEpBD,CACX,CAEA,8BAAcE,CAAwBJ,GAElC,OAAO,IAAIzB,EAAWyB,EAC1B,EC/FG,MAAMK,GAAAA,EAEFC,MAAQ,CAACC,EAAiBC,EAAaF,KAE1CE,GAAO,EACPD,EAAEC,MAAUF,EACZC,EAAEC,IAAUF,CAAK,EANZD,EASFI,KAAO,CAACF,EAAiBC,EAAaE,EAAiBC,KAE1DH,GAAO,EAAGG,GAAO,EACjBJ,EAAEC,KAASE,EAAEC,KACbJ,EAAEC,GAASE,EAAEC,EAAI,EAbZN,EAgBFO,IAAM,SAACL,EAAiBC,EAAaE,EAAiBC,GAC5D,IADyEL,EAAKO,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,EAE9EL,GAAO,EAAGG,GAAO,EACjBJ,EAAEC,MAAUE,EAAEC,KAASL,EACvBC,EAAEC,IAAUE,EAAEC,GAAOL,CACzB,EArBSD,EAuBFW,QAAU,SAACC,EAAmBC,EAAaX,EAAiBC,EAAaE,EAAiBC,GAChG,IAD6GL,EAAKO,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,EAElHK,GAAO,EAAGV,GAAO,EAAGG,GAAO,EAC3BM,EAAIC,MAAUX,EAAEC,KAASE,EAAEC,MAAUL,EACrCW,EAAIC,IAAUX,EAAEC,GAAOE,EAAEC,IAAQL,CACrC,EA5BSD,EA8BFc,cAAgB,CAACZ,EAAiBC,KAGrC,IAAIY,EAAKb,EADTC,GAAO,GACUa,EAAKd,EAAEC,EAAM,GAC9B,OAAOY,EAAKA,EAAKC,EAAKA,CAAE,EAlCnBhB,EAqCFiB,YAAc,CAACf,EAAgBC,EAAaE,EAAiBC,KAEtDA,GAAO,EACjB,IAAIS,EAAKb,EADTC,GAAO,GACWE,EAAEC,GAAMU,EAAKd,EAAEC,EAAM,GAAKE,EAAEC,EAAM,GACpD,OAAOS,EAAKA,EAAKC,EAAKA,CAAE,EAzCnBhB,EA4CFkB,IAAM,CAAChB,EAAiBC,EAAaE,EAAiBC,KAE/CA,GAAO,EACVJ,EADPC,GAAO,GACSE,EAAEC,GAAOJ,EAAEC,EAAM,GAAKE,EAAEC,EAAM,IA/CzCN,EAkDFmB,OAAS,SAACP,EAAmBC,EAAaX,EAAiBC,EAAaE,EAAgBC,GAC9F,IAD2GL,EAAKO,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,EAEhHK,GAAO,EAAGV,GAAO,EAAGG,GAAO,EAC3BM,EAAIC,MAAUX,EAAEC,KAASE,EAAEC,MAAUL,EACrCW,EAAIC,MAAUX,EAAEC,KAASE,EAAEC,MAAUL,EACrCW,EAAIC,IAAUX,EAAEC,GAAOE,EAAEC,IAAQL,CACrC,ECzCG,MAAMmB,EAMDjD,WAAAA,CAAYkD,EAAeC,EAAiBC,GACnD,KALOD,aAAO,OACPD,WAAK,OACNE,UAAI,EAIPjC,KAAK+B,MAAQA,EACb/B,KAAKgC,QAAUA,EACfhC,KAAKiC,KAAOA,CAChB,CAEA,aAAc9B,CAAO4B,EAAeC,GAEhC,OAAO,IAAIF,EAAMC,EAAOC,EAAU,IAAIE,IAC1C,CAEA,oBAAcC,CAAcJ,EAAeC,EAAiBC,GAExD,OAAO,IAAIH,EAAMC,EAAOC,EAASC,EACrC,CAEQG,MAAAA,CAAOC,EAAWC,GAEtB,MAAMC,EAAKC,KAAKC,MAAMJ,EAAIrC,KAAKgC,SACzBU,EAAKF,KAAKC,MAAMH,EAAItC,KAAKgC,SAC/B,OAAOO,EAAKvC,KAAK+B,MAAQW,CAC7B,CAEOzB,GAAAA,CAAIoB,EAAWC,EAAWK,GAE7B,MAAMC,EAAM5C,KAAKoC,OAAOC,EAAGC,GAEtBtC,KAAKiC,KAAKY,IAAID,IACf5C,KAAKiC,KAAKa,IAAIF,EAAK,IAEvB5C,KAAKiC,KAAKc,IAAIH,GAAMI,KAAKL,EAC7B,CAEOM,SAAAA,CAAUZ,EAAWC,GAExB,MAAMM,EAAM5C,KAAKoC,OAAOC,EAAGC,GAC3B,OAAOtC,KAAKiC,KAAKc,IAAIH,IAAQ,EACjC,CAEOM,qBAAAA,CAAsBb,EAAWC,GAEpC,MAAMa,EAAS,GACTC,EAAIpD,KAAKgC,QAcf,OAZAmB,EAAOH,QAAQhD,KAAKiD,UAAUZ,EAAIe,EAAGd,EAAIc,IACzCD,EAAOH,QAAQhD,KAAKiD,UAAUZ,EAAI,EAAGC,EAAIc,IACzCD,EAAOH,QAAQhD,KAAKiD,UAAUZ,EAAIe,EAAGd,EAAIc,IAEzCD,EAAOH,QAAQhD,KAAKiD,UAAUZ,EAAIe,EAAGd,EAAI,IACzCa,EAAOH,QAAQhD,KAAKiD,UAAUZ,EAAI,EAAGC,EAAI,IACzCa,EAAOH,QAAQhD,KAAKiD,UAAUZ,EAAIe,EAAGd,EAAI,IAEzCa,EAAOH,QAAQhD,KAAKiD,UAAUZ,EAAIe,EAAGd,EAAIc,IACzCD,EAAOH,QAAQhD,KAAKiD,UAAUZ,EAAI,EAAGC,EAAIc,IACzCD,EAAOH,QAAQhD,KAAKiD,UAAUZ,EAAIe,EAAGd,EAAIc,IAElCD,CACX,CAEOE,OAAAA,GAEH,MAAO,CAACtB,MAAO/B,KAAK+B,MAAOC,QAAShC,KAAKgC,QAASC,KAAMjC,KAAKiC,KACjE,EChFJ,MAAMqB,EAAiB,IAAIrD,aAAa,GAClCsD,EAAO,IAAItD,aAAa,GAuEjBuD,EAAqBA,CAACC,EACAC,EACAC,EACAhB,EACAiB,KAE/B,MAAMC,EAA4BA,CAACC,EACAC,KAE/B,GAAID,GAAYC,EAAQ,OAAO,EAE/B,OAAQD,EAAWC,IADL,IAAMvB,KAAKwB,IAAID,EAAQ,GAAKvB,KAAKyB,IACb,EAGhCC,EAA4B1E,IAETA,EAAUmE,EAASQ,eAClBR,EAASS,mBA6CnCd,EAAe9C,KAAK,GAnCQ6D,MAExB,MAAMC,EAAcb,EAAKP,sBACrBQ,EAAO1E,gBAAwB,EAAR2D,GACvBe,EAAO1E,gBAAwB,EAAR2D,EAAY,IAEvC,IAAK,IAAI4B,EAAI,EAAGA,EAAID,EAAYnD,OAAQoD,IACxC,CACI,MAAMC,EAASF,EAAYC,GAE3B,GAAI5B,IAAU6B,EAEV,SAGJjB,EAAK/C,KAAK,GAEVE,EAAIW,QAAQkC,EAAM,EAAGG,EAAO1E,gBAAiBwF,EAAQd,EAAO1E,gBAAiB2D,GAC7E,MAAMmB,EAAWtB,KAAKiC,KAAK/D,EAAIc,cAAc+B,EAAM,IAEnD,GAAiB,IAAbO,EAEA,SAIJpD,EAAIC,MAAM4C,EAAM,EAAG,EAAIO,GAEvB,MAAMY,EAAQb,EAA0BC,EAAUH,EAASgB,iBACrDnF,EAAUkE,EAAOlE,QAAQgF,GACzBI,EAAO,EAAIlB,EAAOpE,YAAYqD,GAC9BkC,GAtCmBC,EAsCsBtF,EAtCJuF,EAsCarB,EAAOlE,QAAQmD,IApCzDuB,EAAyBY,GACzBZ,EAAyBa,IACV,GAmC7BrE,EAAIO,IAAIqC,EAAgB,EAAGC,EAAM,EAAIsB,EAAiBH,EAAQE,EAAQpF,EAC1E,CAxC4BwF,IAACF,EAAkBC,CAwC/C,EAGJV,GAEA3D,EAAIO,IAAIyC,EAAO1E,gBAAiB2D,EAAOW,EAAgB,EAAGM,EAAG,EC/HjEqB,KAAKC,UAAaC,IAEd,IAEI,MAAMC,EAAUD,EAAElD,KACZ1B,EAAa3B,EAAW6B,wBAAwB2E,EAAQ1B,QACxDD,EDCiB4B,EAACpD,EACAyB,KAE5B,MAAM4B,EAAqB9C,KAAK+C,OAAOtD,EAAKuD,KAAIC,GAAKA,EAAE9B,SAASgB,mBAE1DlB,EAAO3B,EAAM3B,OAAOuD,EAAO3D,MAAQuF,EAAqB9C,KAAKiC,KAAK,IAExE,IAAK,IAAIiB,EAAI,EAAGA,EAAIhC,EAAO3D,MAAO2F,IAE9BjC,EAAKxC,IAAIyC,EAAO1E,gBAAoB,EAAJ0G,GAAQhC,EAAO1E,gBAAoB,EAAJ0G,EAAQ,GAAIA,GAG/E,OAAOjC,CAAI,ECbM4B,CAAgBD,EAAQO,oBAAqBpF,GAE1D6E,EAAQQ,iBAAiBC,SAAQC,IAE7B,MAAMC,EAAYD,EAAIC,UAChBC,EAAUF,EAAIE,QAEpB,IAAK,IAAIN,EAAIK,EAAWL,EAAIM,EAASN,IAEjClC,EAAmBC,EAAMlD,EAAYuF,EAAIG,MAAOP,EAAGN,EAAQxB,GAC/D,GAER,CACA,MAAOuB,GAEHe,QAAQC,IAAIhB,EAChB,CAGAF,KAAKmB,YAAY,EAAE,C","sources":["unified-particle-physics/engine/solver/data/PointsData.ts","unified-particle-physics/engine/solver/utils/Vec.ts","unified-particle-physics/engine/solver/utils/Grid.ts","unified-particle-physics/engine/solver/constraint/FluidConstraint.ts","unified-particle-physics/engine/solver/paraller/FluidConstraintParallelWorker.ts"],"sourcesContent":["export interface PointsDataShared\n{\n    positionCurrentShaded: SharedArrayBuffer;\n    positionPreviousShared: SharedArrayBuffer;\n    velocityShared: SharedArrayBuffer;\n    massInverseShared: SharedArrayBuffer;\n    densityShared: SharedArrayBuffer;\n    colorShared: SharedArrayBuffer;\n    isNotStaticShared: SharedArrayBuffer;\n    isNotFluidShared: SharedArrayBuffer;\n    count: number;\n\n}\nexport class PointsData implements PointsDataShared\n{\n    public positionCurrentShaded: SharedArrayBuffer;\n    public positionCurrent: Float32Array;\n\n    public positionPreviousShared: SharedArrayBuffer;\n    public positionPrevious: Float32Array;\n\n    public velocityShared: SharedArrayBuffer;\n    public velocity: Float32Array;\n\n    public massInverseShared: SharedArrayBuffer;\n    public massInverse: Float32Array;\n\n    public densityShared: SharedArrayBuffer;\n    public density: Float32Array;\n\n    public colorShared: SharedArrayBuffer;\n    public color: Float32Array;\n\n    // 0 means is it static; 1 it is not\n    public isNotStaticShared: SharedArrayBuffer;\n    public isNotStatic: Int32Array;\n\n    // 0 means it is fluid; 1 it is not\n    public isNotFluidShared: SharedArrayBuffer;\n    public isNotFluid: Int32Array;\n    public count: number;\n\n    private constructor(dataShared: PointsDataShared)\n    {\n        this.positionCurrentShaded = dataShared.positionCurrentShaded;\n        this.positionPreviousShared = dataShared.positionPreviousShared;\n        this.velocityShared = dataShared.velocityShared;\n        this.massInverseShared = dataShared.massInverseShared;\n        this.densityShared = dataShared.densityShared;\n        this.colorShared = dataShared.colorShared;\n        this.isNotStaticShared = dataShared.isNotStaticShared\n        this.isNotFluidShared = dataShared.isNotFluidShared;\n\n        this.positionCurrent = new Float32Array(this.positionCurrentShaded);\n        this.positionPrevious = new Float32Array(this.positionPreviousShared)\n        this.velocity = new Float32Array(this.velocityShared);\n        this.massInverse = new Float32Array(this.massInverseShared);\n        this.density = new Float32Array(this.densityShared);\n        this.color = new Float32Array(this.colorShared);\n        this.isNotStatic = new Int32Array(this.isNotStaticShared);\n        this.isNotFluid = new Int32Array(this.isNotFluidShared);\n\n        this.count = dataShared.count;\n    }\n\n    public static create(maxParticleCount: number): PointsData\n    {\n        const pointsDataShared: PointsDataShared =\n        {\n            positionCurrentShaded: new SharedArrayBuffer(maxParticleCount * 2 * 4),\n            positionPreviousShared: new SharedArrayBuffer(maxParticleCount * 2 * 4),\n            velocityShared: new SharedArrayBuffer(maxParticleCount * 2 * 4),\n            massInverseShared: new SharedArrayBuffer(maxParticleCount * 4),\n            densityShared: new SharedArrayBuffer(maxParticleCount * 4),\n            colorShared: new SharedArrayBuffer(maxParticleCount * 3 * 4),\n            isNotStaticShared: new SharedArrayBuffer(maxParticleCount * 4),\n            isNotFluidShared: new SharedArrayBuffer(maxParticleCount * 4),\n            count: 0,\n        }\n        const pointsData = new PointsData(pointsDataShared);\n        pointsData.positionCurrent.fill(0);\n        pointsData.positionPrevious.fill(0);\n        pointsData.velocity.fill(0);\n        pointsData.massInverse.fill(0);\n        pointsData.density.fill(0);\n        pointsData.color.fill(0);\n        pointsData.isNotStatic.fill(1);\n        pointsData.isNotFluid.fill(1);\n\n        return pointsData;\n    }\n\n    public static createFromSharedBuffers(pointsDataShared: PointsDataShared): PointsData\n    {\n        return new PointsData(pointsDataShared);\n    }\n}","export class Vec\n{\n    static scale = (a: Float32Array, anr: number, scale: number) =>\n    {\n        anr *= 2;\n        a[anr++] *= scale;\n        a[anr]   *= scale;\n    }\n\n    static copy = (a: Float32Array, anr: number, b: Float32Array, bnr: number) =>\n    {\n        anr *= 2; bnr *= 2;\n        a[anr++] = b[bnr++];\n        a[anr]   = b[bnr];\n    }\n\n    static add = (a: Float32Array, anr: number, b: Float32Array, bnr: number, scale = 1.0) =>\n    {\n        anr *= 2; bnr *= 2;\n        a[anr++] += b[bnr++] * scale;\n        a[anr]   += b[bnr] * scale;\n    }\n\n    static setDiff = (dst: Float32Array, dnr: number, a: Float32Array, anr: number, b: Float32Array, bnr: number, scale = 1.0) =>\n    {\n        dnr *= 2; anr *= 2; bnr *= 2;\n        dst[dnr++] = (a[anr++] - b[bnr++]) * scale;\n        dst[dnr]   = (a[anr] - b[bnr]) * scale;\n    }\n\n    static lengthSquared = (a: Float32Array, anr: number) =>\n    {\n        anr *= 2;\n        let a0 = a[anr], a1 = a[anr + 1];\n        return a0 * a0 + a1 * a1;\n    }\n\n    static distSquared = (a: Float32Array,anr: number, b: Float32Array, bnr: number) =>\n    {\n        anr *= 2; bnr *= 2;\n        let a0 = a[anr] - b[bnr], a1 = a[anr + 1] - b[bnr + 1];\n        return a0 * a0 + a1 * a1;\n    }\n\n    static dot = (a: Float32Array, anr: number, b: Float32Array, bnr: number) =>\n    {\n        anr *= 2; bnr *= 2;\n        return a[anr] * b[bnr] + a[anr + 1] * b[bnr + 1];\n    }\n\n    static setSum = (dst: Float32Array, dnr: number, a: Float32Array, anr: number, b: Float32Array,bnr: number, scale = 1.0) =>\n    {\n        dnr *= 2; anr *= 2; bnr *= 2;\n        dst[dnr++] = (a[anr++] + b[bnr++]) * scale;\n        dst[dnr++] = (a[anr++] + b[bnr++]) * scale;\n        dst[dnr]   = (a[anr] + b[bnr]) * scale;\n    }\n}","export interface Grid\n{\n    add: (x: number, y: number, index: number) => void;\n    getInCell: (x: number, y: number) => number[];\n    getInSurroundingCells: (x: number, y: number) => number[];\n    getData: () => GridData;\n}\n\nexport interface GridData\n{\n    spacing: number;\n    width: number;\n    data: Map<number, number[]>;\n}\n\nexport class Grids implements Grid\n{\n    private spacing: number;\n    private width: number;\n    public data: Map<number, number[]>;\n\n    private constructor(width: number, spacing: number, data: Map<number, number[]>)\n    {\n        this.width = width;\n        this.spacing = spacing;\n        this.data = data;\n    }\n\n    public static create(width: number, spacing: number): Grid\n    {\n        return new Grids(width, spacing,  new Map());\n    }\n\n    public static createFromMap(width: number, spacing: number, data: Map<number, number[]>): Grid\n    {\n        return new Grids(width, spacing, data);\n    }\n\n    private getKey(x: number, y: number)\n    {\n        const xi = Math.floor(x / this.spacing);\n        const yi = Math.floor(y / this.spacing);\n        return xi * this.width + yi;\n    }\n\n    public add(x: number, y: number, index: number)\n    {\n        const key = this.getKey(x, y);\n\n        if (!this.data.has(key)) {\n            this.data.set(key, []);\n        }\n        this.data.get(key)!.push(index);\n    }\n\n    public getInCell(x: number, y: number): number[]\n    {\n        const key = this.getKey(x, y);\n        return this.data.get(key) || [];\n    }\n\n    public getInSurroundingCells(x: number, y: number): number[]\n    {\n        const result = [];\n        const s = this.spacing;\n\n        result.push(...this.getInCell(x - s, y - s));\n        result.push(...this.getInCell(x - 0, y - s));\n        result.push(...this.getInCell(x + s, y - s));\n\n        result.push(...this.getInCell(x - s, y - 0));\n        result.push(...this.getInCell(x - 0, y - 0));\n        result.push(...this.getInCell(x + s, y - 0));\n\n        result.push(...this.getInCell(x - s, y + s));\n        result.push(...this.getInCell(x - 0, y + s));\n        result.push(...this.getInCell(x + s, y + s));\n\n        return result;\n    }\n\n    public getData(): GridData\n    {\n        return {width: this.width, spacing: this.spacing, data: this.data};\n    }\n}\n\nexport interface ColumnsData\n{\n    spacing: number;\n    data: Map<number, number[]>;\n}\n\nexport class Columns\n{\n    private spacing: number;\n    public data: Map<number, number[]>;\n\n    private constructor(spacing: number, data: Map<number, number[]>)\n    {\n        this.spacing = spacing;\n        this.data = data;\n    }\n\n    public static create(spacing: number): Columns\n    {\n        return new Columns(spacing, new Map());\n    }\n\n    public static createFromMap(spacing: number, data: Map<number, number[]>)\n    {\n        return new Columns(spacing, data);\n    }\n\n    private getKey(x: number)\n    {\n        return Math.floor(x / this.spacing);\n    }\n\n    public add(x: number, index: number)\n    {\n        const key = this.getKey(x);\n\n        if (!this.data.has(key)) {\n            this.data.set(key, []);\n        }\n        this.data.get(key)!.push(index);\n    }\n\n    public getData(): ColumnsData\n    {\n        return {spacing: this.spacing, data: this.data};\n    }\n}","import {Vec} from \"../utils/Vec\";\nimport {PointsData} from \"../data/PointsData\";\nimport {Columns, Grid, Grids} from \"../utils/Grid\";\n\nconst positionChange = new Float32Array(2);\nconst vecs = new Float32Array(2);\n\nexport interface FluidConstraintData\n{\n    indexFrom: number,\n    indexTo: number;\n    settings: FluidSettings;\n}\n\nexport interface FluidSettings\n{\n    pressureMultiplier: number;\n    smoothingRadius: number;\n    targetDensity: number;\n}\n\nexport const createFluidGrid = (data: FluidConstraintData[],\n                                points: PointsData): Grid =>\n{\n    const maxSmoothingRadius = Math.max(...data.map(d => d.settings.smoothingRadius));\n\n    const grid = Grids.create(points.count, (maxSmoothingRadius / Math.sqrt(2)));\n\n    for (let i = 0; i < points.count; i++)\n    {\n        grid.add(points.positionCurrent[i * 2], points.positionCurrent[i * 2 + 1], i);\n    }\n\n    return grid;\n}\n\n export const setCalculatedPointDensity = (data: FluidConstraintData[],\n                                           grid: Grid,\n                                           points: PointsData) =>\n{\n    // clear density TODO: optimalize\n    points.density.fill(0);\n\n    data.forEach(d =>\n    {\n        for (let index = d.indexFrom; index < d.indexTo; index++)\n        {\n            setCalculatedPointDensityForOnePoint(grid, d.settings, points, index);\n        }\n    })\n}\n\nexport const setCalculatedPointDensityForOnePoint = (grid: Grid,\n                                                     fluidSettings: FluidSettings,\n                                                     points: PointsData,\n                                                     index: number) =>\n{\n    const smoothingKernel = (radius: number, distance: number) =>\n    {\n        if (distance >= radius) return 0;\n        const volume = (Math.PI * Math.pow(radius, 4)) / 6;\n        return (radius - distance) * (radius - distance) / volume;\n    }\n\n    const surrounding = grid.getInSurroundingCells(\n        points.positionCurrent[index * 2],\n        points.positionCurrent[index * 2 + 1]);\n\n    surrounding.forEach(index2 =>\n    {\n        const distance = Math.sqrt(Vec.distSquared(points.positionCurrent, index, points.positionCurrent, index2));\n        const influence = smoothingKernel(fluidSettings.smoothingRadius, distance);\n        points.density[index] += influence * (1 / points.massInverse[index]);\n    });\n}\n\nexport const solveFluidOnePoint = (grid: Grid,\n                                   points: PointsData,\n                                   settings: FluidSettings,\n                                   index: number,\n                                   dt: number) =>\n{\n    const smoothingKernelDerivative = (distance: number,\n                                       radius: number) =>\n    {\n        if (distance >= radius) return 0;\n        const scale = 12 / (Math.pow(radius, 4) * Math.PI);\n        return (distance - radius) * scale;\n    }\n\n    const convertDensityToPressure = (density: number) =>\n    {\n        const densityError = density - settings.targetDensity;\n        return densityError * settings.pressureMultiplier;\n    }\n\n    const calculateSharedPressure = (densityA: number, densityB: number) =>\n    {\n        const pressureA = convertDensityToPressure(densityA);\n        const pressureB = convertDensityToPressure(densityB);\n        return (pressureA + pressureB) / 2;\n    }\n\n    const calculateMoveVector = (): void =>\n    {\n        const surrounding = grid.getInSurroundingCells(\n            points.positionCurrent[index * 2],\n            points.positionCurrent[index * 2 + 1]);\n\n        for (let j = 0; j < surrounding.length; j++)\n        {\n            const index2 = surrounding[j];\n\n            if (index === index2)\n            {\n                continue;\n            }\n\n            vecs.fill(0);\n\n            Vec.setDiff(vecs, 0, points.positionCurrent, index2, points.positionCurrent, index);\n            const distance = Math.sqrt(Vec.lengthSquared(vecs, 0));\n\n            if (distance === 0)\n            {\n                continue;\n            }\n\n            // make unit vector\n            Vec.scale(vecs, 0, 1 / distance);\n\n            const slope = smoothingKernelDerivative(distance, settings.smoothingRadius);\n            const density = points.density[index2];\n            const mass = 1 / points.massInverse[index];\n            const sharedPressure = calculateSharedPressure(density, points.density[index]);\n            Vec.add(positionChange, 0, vecs, 0, (sharedPressure * slope * mass) / density);\n        }\n    }\n    positionChange.fill(0);\n    calculateMoveVector();\n\n    Vec.add(points.positionCurrent, index, positionChange, 0, dt);\n}\n\nexport const solveFluidConstraint = (data: FluidConstraintData[],\n                                     grid: Grid,\n                                     points: PointsData,\n                                     dt: number) =>\n{\n\n    data.forEach(d =>\n    {\n        for (let i = d.indexFrom; i < d.indexTo; i++)\n        {\n            solveFluidOnePoint(grid, points, d.settings, i, dt);\n        }\n    });\n}","import {PointsData, PointsDataShared} from \"../data/PointsData\";\nimport {GridData, Grids} from \"../utils/Grid\";\nimport {createFluidGrid, FluidConstraintData, FluidSettings, solveFluidOnePoint} from \"../constraint/FluidConstraint\";\nimport {Range} from \"../utils/Utils\";\n\nexport interface WorkerRequest\n{\n    points: PointsDataShared;\n    fluidConstraintData: FluidConstraintData[];\n    indexesToProcess: Range<FluidSettings>[];\n    dt: number\n}\n\n// eslint-disable-next-line no-restricted-globals\nself.onmessage = (e: MessageEvent<WorkerRequest>) =>\n{\n    try\n    {\n        const request = e.data;\n        const pointsData = PointsData.createFromSharedBuffers(request.points);\n        const grid = createFluidGrid(request.fluidConstraintData, pointsData);\n\n        request.indexesToProcess.forEach(itp =>\n        {\n            const indexFrom = itp.indexFrom;\n            const indexTo = itp.indexTo;\n\n            for (let i = indexFrom; i < indexTo; i++)\n            {\n                solveFluidOnePoint(grid, pointsData, itp.value, i, request.dt);\n            }\n        })\n    }\n    catch (e)\n    {\n        console.log(e);\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    self.postMessage(0);\n};\n\nexport {};"],"names":["PointsData","constructor","dataShared","positionCurrentShaded","positionCurrent","positionPreviousShared","positionPrevious","velocityShared","velocity","massInverseShared","massInverse","densityShared","density","colorShared","color","isNotStaticShared","isNotStatic","isNotFluidShared","isNotFluid","count","this","Float32Array","Int32Array","create","maxParticleCount","pointsDataShared","SharedArrayBuffer","pointsData","fill","createFromSharedBuffers","Vec","scale","a","anr","copy","b","bnr","add","arguments","length","undefined","setDiff","dst","dnr","lengthSquared","a0","a1","distSquared","dot","setSum","Grids","width","spacing","data","Map","createFromMap","getKey","x","y","xi","Math","floor","yi","index","key","has","set","get","push","getInCell","getInSurroundingCells","result","s","getData","positionChange","vecs","solveFluidOnePoint","grid","points","settings","dt","smoothingKernelDerivative","distance","radius","pow","PI","convertDensityToPressure","targetDensity","pressureMultiplier","calculateMoveVector","surrounding","j","index2","sqrt","slope","smoothingRadius","mass","sharedPressure","densityA","densityB","calculateSharedPressure","self","onmessage","e","request","createFluidGrid","maxSmoothingRadius","max","map","d","i","fluidConstraintData","indexesToProcess","forEach","itp","indexFrom","indexTo","value","console","log","postMessage"],"sourceRoot":""}
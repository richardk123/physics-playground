(()=>{"use strict";class t{constructor(t){this.positionCurrentShaded=void 0,this.positionCurrent=void 0,this.positionPreviousShared=void 0,this.positionPrevious=void 0,this.velocityShared=void 0,this.velocity=void 0,this.massInverseShared=void 0,this.massInverse=void 0,this.densityShared=void 0,this.density=void 0,this.colorShared=void 0,this.color=void 0,this.isNotStaticShared=void 0,this.isNotStatic=void 0,this.isNotFluidShared=void 0,this.isNotFluid=void 0,this.count=void 0,this.positionCurrentShaded=t.positionCurrentShaded,this.positionPreviousShared=t.positionPreviousShared,this.velocityShared=t.velocityShared,this.massInverseShared=t.massInverseShared,this.densityShared=t.densityShared,this.colorShared=t.colorShared,this.isNotStaticShared=t.isNotStaticShared,this.isNotFluidShared=t.isNotFluidShared,this.positionCurrent=new Float32Array(this.positionCurrentShaded),this.positionPrevious=new Float32Array(this.positionPreviousShared),this.velocity=new Float32Array(this.velocityShared),this.massInverse=new Float32Array(this.massInverseShared),this.density=new Float32Array(this.densityShared),this.color=new Float32Array(this.colorShared),this.isNotStatic=new Int32Array(this.isNotStaticShared),this.isNotFluid=new Int32Array(this.isNotFluidShared),this.count=t.count}static create(i){const e={positionCurrentShaded:new SharedArrayBuffer(2*i*4),positionPreviousShared:new SharedArrayBuffer(2*i*4),velocityShared:new SharedArrayBuffer(2*i*4),massInverseShared:new SharedArrayBuffer(4*i),densityShared:new SharedArrayBuffer(4*i),colorShared:new SharedArrayBuffer(3*i*4),isNotStaticShared:new SharedArrayBuffer(4*i),isNotFluidShared:new SharedArrayBuffer(4*i),count:0},s=new t(e);return s.positionCurrent.fill(0),s.positionPrevious.fill(0),s.velocity.fill(0),s.massInverse.fill(0),s.density.fill(0),s.color.fill(0),s.isNotStatic.fill(1),s.isNotFluid.fill(1),s}static createFromSharedBuffers(i){return new t(i)}}class i{constructor(t,i,e){this.spacing=void 0,this.width=void 0,this.data=void 0,this.width=t,this.spacing=i,this.data=e}static create(t,e){return new i(t,e,new Map)}static createFromMap(t,e,s){return new i(t,e,s)}getKey(t,i){const e=Math.floor(t/this.spacing),s=Math.floor(i/this.spacing);return e*this.width+s}add(t,i,e){const s=this.getKey(t,i);this.data.has(s)||this.data.set(s,[]),this.data.get(s).push(e)}getInCell(t,i){const e=this.getKey(t,i);return this.data.get(e)||[]}getInSurroundingCells(t,i){const e=[],s=this.spacing;return e.push(...this.getInCell(t-s,i-s)),e.push(...this.getInCell(t-0,i-s)),e.push(...this.getInCell(t+s,i-s)),e.push(...this.getInCell(t-s,i-0)),e.push(...this.getInCell(t-0,i-0)),e.push(...this.getInCell(t+s,i-0)),e.push(...this.getInCell(t-s,i+s)),e.push(...this.getInCell(t-0,i+s)),e.push(...this.getInCell(t+s,i+s)),e}getData(){return{width:this.width,spacing:this.spacing,data:this.data}}}class e{}e.scale=(t,i,e)=>{i*=2,t[i++]*=e,t[i]*=e},e.copy=(t,i,e,s)=>{i*=2,s*=2,t[i++]=e[s++],t[i]=e[s]},e.add=function(t,i,e,s){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1;i*=2,s*=2,t[i++]+=e[s++]*r,t[i]+=e[s]*r},e.setDiff=function(t,i,e,s,r,o){let a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;i*=2,s*=2,o*=2,t[i++]=(e[s++]-r[o++])*a,t[i]=(e[s]-r[o])*a},e.lengthSquared=(t,i)=>{let e=t[i*=2],s=t[i+1];return e*e+s*s},e.distSquared=(t,i,e,s)=>{s*=2;let r=t[i*=2]-e[s],o=t[i+1]-e[s+1];return r*r+o*o},e.dot=(t,i,e,s)=>(s*=2,t[i*=2]*e[s]+t[i+1]*e[s+1]),e.setSum=function(t,i,e,s,r,o){let a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;i*=2,s*=2,o*=2,t[i++]=(e[s++]+r[o++])*a,t[i++]=(e[s++]+r[o++])*a,t[i]=(e[s]+r[o])*a};new Float32Array(2),new Float32Array(2);const s=(t,i,s,r)=>{t.getInSurroundingCells(s.positionCurrent[2*r],s.positionCurrent[2*r+1]).forEach((t=>{const o=Math.sqrt(e.distSquared(s.positionCurrent,r,s.positionCurrent,t)),a=((t,i)=>i>=t?0:(t-i)*(t-i)/(Math.PI*Math.pow(t,4)/6))(i.smoothingRadius,o);s.density[r]+=a*(1/s.massInverse[r])}))};self.onmessage=e=>{try{const r=e.data,o=t.createFromSharedBuffers(r.points),a=i.createFromMap(r.gridData.width,r.gridData.spacing,r.gridData.data);r.indexesToProcess.forEach((t=>{const i=t.indexFrom,e=t.indexTo;for(let r=i;r<e;r++)s(a,t.value,o,r)}))}catch(e){console.log(e)}self.postMessage("fluid density parallel worker success")}})();
//# sourceMappingURL=293.17e52d86.chunk.js.map
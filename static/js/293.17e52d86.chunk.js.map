{"version":3,"file":"static/js/293.17e52d86.chunk.js","mappings":"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","sources":["unified-particle-physics/engine/solver/data/PointsData.ts","unified-particle-physics/engine/solver/utils/Grid.ts","unified-particle-physics/engine/solver/utils/Vec.ts","unified-particle-physics/engine/solver/constraint/FluidConstraint.ts","unified-particle-physics/engine/solver/paraller/FluidDensityParallelWorker.ts"],"sourcesContent":["export interface PointsDataShared\n{\n    positionCurrentShaded: SharedArrayBuffer;\n    positionPreviousShared: SharedArrayBuffer;\n    velocityShared: SharedArrayBuffer;\n    massInverseShared: SharedArrayBuffer;\n    densityShared: SharedArrayBuffer;\n    colorShared: SharedArrayBuffer;\n    isNotStaticShared: SharedArrayBuffer;\n    isNotFluidShared: SharedArrayBuffer;\n    count: number;\n\n}\nexport class PointsData implements PointsDataShared\n{\n    public positionCurrentShaded: SharedArrayBuffer;\n    public positionCurrent: Float32Array;\n\n    public positionPreviousShared: SharedArrayBuffer;\n    public positionPrevious: Float32Array;\n\n    public velocityShared: SharedArrayBuffer;\n    public velocity: Float32Array;\n\n    public massInverseShared: SharedArrayBuffer;\n    public massInverse: Float32Array;\n\n    public densityShared: SharedArrayBuffer;\n    public density: Float32Array;\n\n    public colorShared: SharedArrayBuffer;\n    public color: Float32Array;\n\n    // 0 means is it static; 1 it is not\n    public isNotStaticShared: SharedArrayBuffer;\n    public isNotStatic: Int32Array;\n\n    // 0 means it is fluid; 1 it is not\n    public isNotFluidShared: SharedArrayBuffer;\n    public isNotFluid: Int32Array;\n    public count: number;\n\n    private constructor(dataShared: PointsDataShared)\n    {\n        this.positionCurrentShaded = dataShared.positionCurrentShaded;\n        this.positionPreviousShared = dataShared.positionPreviousShared;\n        this.velocityShared = dataShared.velocityShared;\n        this.massInverseShared = dataShared.massInverseShared;\n        this.densityShared = dataShared.densityShared;\n        this.colorShared = dataShared.colorShared;\n        this.isNotStaticShared = dataShared.isNotStaticShared\n        this.isNotFluidShared = dataShared.isNotFluidShared;\n\n        this.positionCurrent = new Float32Array(this.positionCurrentShaded);\n        this.positionPrevious = new Float32Array(this.positionPreviousShared)\n        this.velocity = new Float32Array(this.velocityShared);\n        this.massInverse = new Float32Array(this.massInverseShared);\n        this.density = new Float32Array(this.densityShared);\n        this.color = new Float32Array(this.colorShared);\n        this.isNotStatic = new Int32Array(this.isNotStaticShared);\n        this.isNotFluid = new Int32Array(this.isNotFluidShared);\n\n        this.count = dataShared.count;\n    }\n\n    public static create(maxParticleCount: number): PointsData\n    {\n        const pointsDataShared: PointsDataShared =\n        {\n            positionCurrentShaded: new SharedArrayBuffer(maxParticleCount * 2 * 4),\n            positionPreviousShared: new SharedArrayBuffer(maxParticleCount * 2 * 4),\n            velocityShared: new SharedArrayBuffer(maxParticleCount * 2 * 4),\n            massInverseShared: new SharedArrayBuffer(maxParticleCount * 4),\n            densityShared: new SharedArrayBuffer(maxParticleCount * 4),\n            colorShared: new SharedArrayBuffer(maxParticleCount * 3 * 4),\n            isNotStaticShared: new SharedArrayBuffer(maxParticleCount * 4),\n            isNotFluidShared: new SharedArrayBuffer(maxParticleCount * 4),\n            count: 0,\n        }\n        const pointsData = new PointsData(pointsDataShared);\n        pointsData.positionCurrent.fill(0);\n        pointsData.positionPrevious.fill(0);\n        pointsData.velocity.fill(0);\n        pointsData.massInverse.fill(0);\n        pointsData.density.fill(0);\n        pointsData.color.fill(0);\n        pointsData.isNotStatic.fill(1);\n        pointsData.isNotFluid.fill(1);\n\n        return pointsData;\n    }\n\n    public static createFromSharedBuffers(pointsDataShared: PointsDataShared): PointsData\n    {\n        return new PointsData(pointsDataShared);\n    }\n}","export interface Grid\n{\n    add: (x: number, y: number, index: number) => void;\n    getInCell: (x: number, y: number) => number[];\n    getInSurroundingCells: (x: number, y: number) => number[];\n    getData: () => GridData;\n}\n\nexport interface GridData\n{\n    spacing: number;\n    width: number;\n    data: Map<number, number[]>;\n}\n\nexport class Grids implements Grid\n{\n    private spacing: number;\n    private width: number;\n    public data: Map<number, number[]>;\n\n    private constructor(width: number, spacing: number, data: Map<number, number[]>)\n    {\n        this.width = width;\n        this.spacing = spacing;\n        this.data = data;\n    }\n\n    public static create(width: number, spacing: number): Grid\n    {\n        return new Grids(width, spacing,  new Map());\n    }\n\n    public static createFromMap(width: number, spacing: number, data: Map<number, number[]>): Grid\n    {\n        return new Grids(width, spacing, data);\n    }\n\n    private getKey(x: number, y: number)\n    {\n        const xi = Math.floor(x / this.spacing);\n        const yi = Math.floor(y / this.spacing);\n        return xi * this.width + yi;\n    }\n\n    public add(x: number, y: number, index: number)\n    {\n        const key = this.getKey(x, y);\n\n        if (!this.data.has(key)) {\n            this.data.set(key, []);\n        }\n        this.data.get(key)!.push(index);\n    }\n\n    public getInCell(x: number, y: number): number[]\n    {\n        const key = this.getKey(x, y);\n        return this.data.get(key) || [];\n    }\n\n    public getInSurroundingCells(x: number, y: number): number[]\n    {\n        const result = [];\n        const s = this.spacing;\n\n        result.push(...this.getInCell(x - s, y - s));\n        result.push(...this.getInCell(x - 0, y - s));\n        result.push(...this.getInCell(x + s, y - s));\n\n        result.push(...this.getInCell(x - s, y - 0));\n        result.push(...this.getInCell(x - 0, y - 0));\n        result.push(...this.getInCell(x + s, y - 0));\n\n        result.push(...this.getInCell(x - s, y + s));\n        result.push(...this.getInCell(x - 0, y + s));\n        result.push(...this.getInCell(x + s, y + s));\n\n        return result;\n    }\n\n    public getData(): GridData\n    {\n        return {width: this.width, spacing: this.spacing, data: this.data};\n    }\n}\n//\n// export class ColumnsGrid\n// {\n//     private spacing: number;\n//     private width: number;\n//     public data: Map<number, number[]>;\n//\n//     private constructor(spacing: number, data: Map<number, number[]>)\n//     {\n//         this.spacing = spacing;\n//         this.data = data;\n//     }\n//\n//     private getKey(x: number)\n//     {\n//         return Math.floor(x / this.spacing);\n//     }\n//\n//     public add(x: number, y: number, index: number)\n//     {\n//         const key = this.getKey(x, y);\n//\n//         if (!this.data.has(key)) {\n//             this.data.set(key, []);\n//         }\n//         this.data.get(key)!.push(index);\n//     }\n// }","export class Vec\n{\n    static scale = (a: Float32Array, anr: number, scale: number) =>\n    {\n        anr *= 2;\n        a[anr++] *= scale;\n        a[anr]   *= scale;\n    }\n\n    static copy = (a: Float32Array, anr: number, b: Float32Array, bnr: number) =>\n    {\n        anr *= 2; bnr *= 2;\n        a[anr++] = b[bnr++];\n        a[anr]   = b[bnr];\n    }\n\n    static add = (a: Float32Array, anr: number, b: Float32Array, bnr: number, scale = 1.0) =>\n    {\n        anr *= 2; bnr *= 2;\n        a[anr++] += b[bnr++] * scale;\n        a[anr]   += b[bnr] * scale;\n    }\n\n    static setDiff = (dst: Float32Array, dnr: number, a: Float32Array, anr: number, b: Float32Array, bnr: number, scale = 1.0) =>\n    {\n        dnr *= 2; anr *= 2; bnr *= 2;\n        dst[dnr++] = (a[anr++] - b[bnr++]) * scale;\n        dst[dnr]   = (a[anr] - b[bnr]) * scale;\n    }\n\n    static lengthSquared = (a: Float32Array, anr: number) =>\n    {\n        anr *= 2;\n        let a0 = a[anr], a1 = a[anr + 1];\n        return a0 * a0 + a1 * a1;\n    }\n\n    static distSquared = (a: Float32Array,anr: number, b: Float32Array, bnr: number) =>\n    {\n        anr *= 2; bnr *= 2;\n        let a0 = a[anr] - b[bnr], a1 = a[anr + 1] - b[bnr + 1];\n        return a0 * a0 + a1 * a1;\n    }\n\n    static dot = (a: Float32Array, anr: number, b: Float32Array, bnr: number) =>\n    {\n        anr *= 2; bnr *= 2;\n        return a[anr] * b[bnr] + a[anr + 1] * b[bnr + 1];\n    }\n\n    static setSum = (dst: Float32Array, dnr: number, a: Float32Array, anr: number, b: Float32Array,bnr: number, scale = 1.0) =>\n    {\n        dnr *= 2; anr *= 2; bnr *= 2;\n        dst[dnr++] = (a[anr++] + b[bnr++]) * scale;\n        dst[dnr++] = (a[anr++] + b[bnr++]) * scale;\n        dst[dnr]   = (a[anr] + b[bnr]) * scale;\n    }\n}","import {Vec} from \"../utils/Vec\";\nimport {PointsData} from \"../data/PointsData\";\nimport {Grid, Grids} from \"../utils/Grid\";\n\nconst positionChange = new Float32Array(2);\nconst vecs = new Float32Array(2);\n\nexport interface FluidConstraintData\n{\n    indexFrom: number,\n    indexTo: number;\n    settings: FluidSettings;\n}\n\nexport interface FluidSettings\n{\n    pressureMultiplier: number;\n    smoothingRadius: number;\n    targetDensity: number;\n}\n\nexport const createFluidGrid = (data: FluidConstraintData[],\n                                points: PointsData): Grid =>\n{\n    const maxSmoothingRadius = Math.max(...data.map(d => d.settings.smoothingRadius));\n\n    const grid = Grids.create(points.count, (maxSmoothingRadius / Math.sqrt(2)));\n\n    for (let i = 0; i < points.count; i++)\n    {\n        grid.add(points.positionCurrent[i * 2], points.positionCurrent[i * 2 + 1], i);\n    }\n\n    return grid;\n}\n\n export const setCalculatedPointDensity = (data: FluidConstraintData[],\n                                           grid: Grid,\n                                           points: PointsData) =>\n{\n    // clear density TODO: optimalize\n    points.density.fill(0);\n\n    data.forEach(d =>\n    {\n        for (let index = d.indexFrom; index < d.indexTo; index++)\n        {\n            setCalculatedPointDensityForOnePoint(grid, d.settings, points, index);\n        }\n    })\n}\n\nexport const setCalculatedPointDensityForOnePoint = (grid: Grid,\n                                                     fluidSettings: FluidSettings,\n                                                     points: PointsData,\n                                                     index: number) =>\n{\n    const smoothingKernel = (radius: number, distance: number) =>\n    {\n        if (distance >= radius) return 0;\n        const volume = (Math.PI * Math.pow(radius, 4)) / 6;\n        return (radius - distance) * (radius - distance) / volume;\n    }\n\n    const surrounding = grid.getInSurroundingCells(\n        points.positionCurrent[index * 2],\n        points.positionCurrent[index * 2 + 1]);\n\n    surrounding.forEach(index2 =>\n    {\n        const distance = Math.sqrt(Vec.distSquared(points.positionCurrent, index, points.positionCurrent, index2));\n        const influence = smoothingKernel(fluidSettings.smoothingRadius, distance);\n        points.density[index] += influence * (1 / points.massInverse[index]);\n    });\n}\n\nexport const solveFluidOnePoint = (grid: Grid,\n                                   points: PointsData,\n                                   settings: FluidSettings,\n                                   index: number,\n                                   dt: number) =>\n{\n    const smoothingKernelDerivative = (distance: number,\n                                       radius: number) =>\n    {\n        if (distance >= radius) return 0;\n        const scale = 12 / (Math.pow(radius, 4) * Math.PI);\n        return (distance - radius) * scale;\n    }\n\n    const convertDensityToPressure = (density: number) =>\n    {\n        const densityError = density - settings.targetDensity;\n        return densityError * settings.pressureMultiplier;\n    }\n\n    const calculateSharedPressure = (densityA: number, densityB: number) =>\n    {\n        const pressureA = convertDensityToPressure(densityA);\n        const pressureB = convertDensityToPressure(densityB);\n        return (pressureA + pressureB) / 2;\n    }\n\n    const calculateMoveVector = (): void =>\n    {\n        const surrounding = grid.getInSurroundingCells(\n            points.positionCurrent[index * 2],\n            points.positionCurrent[index * 2 + 1]);\n\n        for (let j = 0; j < surrounding.length; j++)\n        {\n            const index2 = surrounding[j];\n\n            if (index === index2)\n            {\n                continue;\n            }\n\n            vecs.fill(0);\n\n            Vec.setDiff(vecs, 0, points.positionCurrent, index2, points.positionCurrent, index);\n            const distance = Math.sqrt(Vec.lengthSquared(vecs, 0));\n\n            if (distance === 0)\n            {\n                continue;\n            }\n\n            // make unit vector\n            Vec.scale(vecs, 0, 1 / distance);\n\n            const slope = smoothingKernelDerivative(distance, settings.smoothingRadius);\n            const density = points.density[index2];\n            const mass = 1 / points.massInverse[index];\n            const sharedPressure = calculateSharedPressure(density, points.density[index]);\n            Vec.add(positionChange, 0, vecs, 0, (sharedPressure * slope * mass) / density);\n        }\n    }\n    positionChange.fill(0);\n    calculateMoveVector();\n\n    Vec.add(points.positionCurrent, index, positionChange, 0, dt);\n}\n\nexport const solveFluidConstraint = (data: FluidConstraintData[],\n                                     grid: Grid,\n                                     points: PointsData,\n                                     dt: number) =>\n{\n\n    data.forEach(d =>\n    {\n        for (let i = d.indexFrom; i < d.indexTo; i++)\n        {\n            solveFluidOnePoint(grid, points, d.settings, i, dt);\n        }\n    });\n}","import {PointsData, PointsDataShared} from \"../data/PointsData\";\nimport {GridData, Grids} from \"../utils/Grid\";\nimport {FluidSettings, setCalculatedPointDensityForOnePoint, solveFluidOnePoint} from \"../constraint/FluidConstraint\";\nimport {Range} from \"../utils/Utils\";\n\nexport interface WorkerRequest\n{\n    points: PointsDataShared;\n    gridData: GridData;\n    indexesToProcess: Range<FluidSettings>[];\n}\n\n// eslint-disable-next-line no-restricted-globals\nself.onmessage = (e: MessageEvent<WorkerRequest>) =>\n{\n    try\n    {\n        const request = e.data;\n        const pointsData = PointsData.createFromSharedBuffers(request.points);\n        const grid = Grids.createFromMap(request.gridData.width, request.gridData.spacing, request.gridData.data);\n\n        request.indexesToProcess.forEach(itp =>\n        {\n            const indexFrom = itp.indexFrom;\n            const indexTo = itp.indexTo;\n\n            for (let i = indexFrom; i < indexTo; i++)\n            {\n                setCalculatedPointDensityForOnePoint(grid, itp.value, pointsData, i);\n            }\n        })\n    }\n    catch (e)\n    {\n        console.log(e);\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    self.postMessage(\"fluid density parallel worker success\");\n};\n\nexport {};"],"names":["PointsData","constructor","dataShared","positionCurrentShaded","positionCurrent","positionPreviousShared","positionPrevious","velocityShared","velocity","massInverseShared","massInverse","densityShared","density","colorShared","color","isNotStaticShared","isNotStatic","isNotFluidShared","isNotFluid","count","this","Float32Array","Int32Array","create","maxParticleCount","pointsDataShared","SharedArrayBuffer","pointsData","fill","createFromSharedBuffers","Grids","width","spacing","data","Map","createFromMap","getKey","x","y","xi","Math","floor","yi","add","index","key","has","set","get","push","getInCell","getInSurroundingCells","result","s","getData","Vec","scale","a","anr","copy","b","bnr","arguments","length","undefined","setDiff","dst","dnr","lengthSquared","a0","a1","distSquared","dot","setSum","setCalculatedPointDensityForOnePoint","grid","fluidSettings","points","forEach","index2","distance","sqrt","influence","smoothingKernel","radius","PI","pow","smoothingRadius","self","onmessage","e","request","gridData","indexesToProcess","itp","indexFrom","indexTo","i","value","console","log","postMessage"],"sourceRoot":""}
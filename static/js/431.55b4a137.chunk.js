(()=>{"use strict";class t{constructor(t){this.positionCurrentShaded=void 0,this.positionCurrent=void 0,this.positionPreviousShared=void 0,this.positionPrevious=void 0,this.velocityShared=void 0,this.velocity=void 0,this.massInverseShared=void 0,this.massInverse=void 0,this.densityShared=void 0,this.density=void 0,this.colorShared=void 0,this.color=void 0,this.isNotStaticShared=void 0,this.isNotStatic=void 0,this.isNotFluidShared=void 0,this.isNotFluid=void 0,this.count=void 0,this.positionCurrentShaded=t.positionCurrentShaded,this.positionPreviousShared=t.positionPreviousShared,this.velocityShared=t.velocityShared,this.massInverseShared=t.massInverseShared,this.densityShared=t.densityShared,this.colorShared=t.colorShared,this.isNotStaticShared=t.isNotStaticShared,this.isNotFluidShared=t.isNotFluidShared,this.positionCurrent=new Float32Array(this.positionCurrentShaded),this.positionPrevious=new Float32Array(this.positionPreviousShared),this.velocity=new Float32Array(this.velocityShared),this.massInverse=new Float32Array(this.massInverseShared),this.density=new Float32Array(this.densityShared),this.color=new Float32Array(this.colorShared),this.isNotStatic=new Int32Array(this.isNotStaticShared),this.isNotFluid=new Int32Array(this.isNotFluidShared),this.count=t.count}static create(i){const e={positionCurrentShaded:new SharedArrayBuffer(2*i*4),positionPreviousShared:new SharedArrayBuffer(2*i*4),velocityShared:new SharedArrayBuffer(2*i*4),massInverseShared:new SharedArrayBuffer(4*i),densityShared:new SharedArrayBuffer(4*i),colorShared:new SharedArrayBuffer(3*i*4),isNotStaticShared:new SharedArrayBuffer(4*i),isNotFluidShared:new SharedArrayBuffer(4*i),count:0},s=new t(e);return s.positionCurrent.fill(0),s.positionPrevious.fill(0),s.velocity.fill(0),s.massInverse.fill(0),s.density.fill(0),s.color.fill(0),s.isNotStatic.fill(1),s.isNotFluid.fill(1),s}static createFromSharedBuffers(i){return new t(i)}}class i{}i.scale=(t,i,e)=>{i*=2,t[i++]*=e,t[i]*=e},i.copy=(t,i,e,s)=>{i*=2,s*=2,t[i++]=e[s++],t[i]=e[s]},i.add=function(t,i,e,s){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1;i*=2,s*=2,t[i++]+=e[s++]*r,t[i]+=e[s]*r},i.setDiff=function(t,i,e,s,r,o){let n=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;i*=2,s*=2,o*=2,t[i++]=(e[s++]-r[o++])*n,t[i]=(e[s]-r[o])*n},i.lengthSquared=(t,i)=>{let e=t[i*=2],s=t[i+1];return e*e+s*s},i.distSquared=(t,i,e,s)=>{s*=2;let r=t[i*=2]-e[s],o=t[i+1]-e[s+1];return r*r+o*o},i.dot=(t,i,e,s)=>(s*=2,t[i*=2]*e[s]+t[i+1]*e[s+1]),i.setSum=function(t,i,e,s,r,o){let n=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;i*=2,s*=2,o*=2,t[i++]=(e[s++]+r[o++])*n,t[i++]=(e[s++]+r[o++])*n,t[i]=(e[s]+r[o])*n};class e{constructor(t,i,e){this.spacing=void 0,this.width=void 0,this.data=void 0,this.width=t,this.spacing=i,this.data=e}static create(t,i){return new e(t,i,new Map)}static createFromMap(t,i,s){return new e(t,i,s)}getKey(t,i){const e=Math.floor(t/this.spacing),s=Math.floor(i/this.spacing);return e*this.width+s}add(t,i,e){const s=this.getKey(t,i);this.data.has(s)||this.data.set(s,[]),this.data.get(s).push(e)}getInCell(t,i){const e=this.getKey(t,i);return this.data.get(e)||[]}getInSurroundingCells(t,i){const e=[],s=this.spacing;return e.push(...this.getInCell(t-s,i-s)),e.push(...this.getInCell(t-0,i-s)),e.push(...this.getInCell(t+s,i-s)),e.push(...this.getInCell(t-s,i-0)),e.push(...this.getInCell(t-0,i-0)),e.push(...this.getInCell(t+s,i-0)),e.push(...this.getInCell(t-s,i+s)),e.push(...this.getInCell(t-0,i+s)),e.push(...this.getInCell(t+s,i+s)),e}getData(){return{width:this.width,spacing:this.spacing,data:this.data}}}const s=new Float32Array(2),r=new Float32Array(2),o=(t,e,o,n,a)=>{const h=(t,i)=>{if(t>=i)return 0;return(t-i)*(12/(Math.pow(i,4)*Math.PI))},d=t=>(t-o.targetDensity)*o.pressureMultiplier;s.fill(0),(()=>{const a=t.getInSurroundingCells(e.positionCurrent[2*n],e.positionCurrent[2*n+1]);for(let t=0;t<a.length;t++){const c=a[t];if(n===c)continue;r.fill(0),i.setDiff(r,0,e.positionCurrent,c,e.positionCurrent,n);const S=Math.sqrt(i.lengthSquared(r,0));if(0===S)continue;i.scale(r,0,1/S);const v=h(S,o.smoothingRadius),f=e.density[c],p=1/e.massInverse[n],y=(l=f,u=e.density[n],(d(l)+d(u))/2);i.add(s,0,r,0,y*v*p/f)}var l,u})(),i.add(e.positionCurrent,n,s,0,a)};self.onmessage=i=>{try{const s=i.data,r=t.createFromSharedBuffers(s.points),n=((t,i)=>{const s=Math.max(...t.map((t=>t.settings.smoothingRadius))),r=e.create(i.count,s/Math.sqrt(2));for(let e=0;e<i.count;e++)r.add(i.positionCurrent[2*e],i.positionCurrent[2*e+1],e);return r})(s.fluidConstraintData,r);s.indexesToProcess.forEach((t=>{const i=t.indexFrom,e=t.indexTo;for(let a=i;a<e;a++)o(n,r,t.value,a,s.dt)}))}catch(i){console.log(i)}self.postMessage(0)}})();
//# sourceMappingURL=431.55b4a137.chunk.js.map